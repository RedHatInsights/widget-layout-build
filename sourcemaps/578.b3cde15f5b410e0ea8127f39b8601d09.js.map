{"version":3,"file":"js/578.0bc10dc6c4abf674f645.js","mappings":"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","sources":["webpack:///./node_modules/jotai/esm/vanilla.mjs","webpack:///./node_modules/jotai/esm/react.mjs"],"sourcesContent":["let keyCount = 0;\nfunction atom(read, write) {\n  const key = `atom${++keyCount}`;\n  const config = {\n    toString: () => key\n  };\n  if (typeof read === \"function\") {\n    config.read = read;\n  } else {\n    config.init = read;\n    config.read = defaultRead;\n    config.write = defaultWrite;\n  }\n  if (write) {\n    config.write = write;\n  }\n  return config;\n}\nfunction defaultRead(get) {\n  return get(this);\n}\nfunction defaultWrite(get, set, arg) {\n  return set(\n    this,\n    typeof arg === \"function\" ? arg(get(this)) : arg\n  );\n}\n\nconst isSelfAtom = (atom, a) => atom.unstable_is ? atom.unstable_is(a) : a === atom;\nconst hasInitialValue = (atom) => \"init\" in atom;\nconst isActuallyWritableAtom = (atom) => !!atom.write;\nconst cancelPromiseMap = /* @__PURE__ */ new WeakMap();\nconst registerCancelPromise = (promise, cancel) => {\n  cancelPromiseMap.set(promise, cancel);\n  promise.catch(() => {\n  }).finally(() => cancelPromiseMap.delete(promise));\n};\nconst cancelPromise = (promise, next) => {\n  const cancel = cancelPromiseMap.get(promise);\n  if (cancel) {\n    cancelPromiseMap.delete(promise);\n    cancel(next);\n  }\n};\nconst resolvePromise = (promise, value) => {\n  promise.status = \"fulfilled\";\n  promise.value = value;\n};\nconst rejectPromise = (promise, e) => {\n  promise.status = \"rejected\";\n  promise.reason = e;\n};\nconst isPromiseLike = (x) => typeof (x == null ? void 0 : x.then) === \"function\";\nconst isEqualAtomValue = (a, b) => !!a && \"v\" in a && \"v\" in b && Object.is(a.v, b.v);\nconst isEqualAtomError = (a, b) => !!a && \"e\" in a && \"e\" in b && Object.is(a.e, b.e);\nconst hasPromiseAtomValue = (a) => !!a && \"v\" in a && a.v instanceof Promise;\nconst isEqualPromiseAtomValue = (a, b) => \"v\" in a && \"v\" in b && a.v.orig && a.v.orig === b.v.orig;\nconst returnAtomValue = (atomState) => {\n  if (\"e\" in atomState) {\n    throw atomState.e;\n  }\n  return atomState.v;\n};\nconst createStore = () => {\n  const atomStateMap = /* @__PURE__ */ new WeakMap();\n  const mountedMap = /* @__PURE__ */ new WeakMap();\n  const pendingMap = /* @__PURE__ */ new Map();\n  let storeListenersRev2;\n  let mountedAtoms;\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    storeListenersRev2 = /* @__PURE__ */ new Set();\n    mountedAtoms = /* @__PURE__ */ new Set();\n  }\n  const getAtomState = (atom) => atomStateMap.get(atom);\n  const setAtomState = (atom, atomState) => {\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      Object.freeze(atomState);\n    }\n    const prevAtomState = getAtomState(atom);\n    atomStateMap.set(atom, atomState);\n    if (!pendingMap.has(atom)) {\n      pendingMap.set(atom, prevAtomState);\n    }\n    if (hasPromiseAtomValue(prevAtomState)) {\n      const next = \"v\" in atomState ? atomState.v instanceof Promise ? atomState.v : Promise.resolve(atomState.v) : Promise.reject(atomState.e);\n      if (prevAtomState.v !== next) {\n        cancelPromise(prevAtomState.v, next);\n      }\n    }\n  };\n  const updateDependencies = (atom, nextAtomState, nextDependencies, keepPreviousDependencies) => {\n    const dependencies = new Map(\n      keepPreviousDependencies ? nextAtomState.d : null\n    );\n    let changed = false;\n    nextDependencies.forEach((aState, a) => {\n      if (!aState && isSelfAtom(atom, a)) {\n        aState = nextAtomState;\n      }\n      if (aState) {\n        dependencies.set(a, aState);\n        if (nextAtomState.d.get(a) !== aState) {\n          changed = true;\n        }\n      } else if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n        console.warn(\"[Bug] atom state not found\");\n      }\n    });\n    if (changed || nextAtomState.d.size !== dependencies.size) {\n      nextAtomState.d = dependencies;\n    }\n  };\n  const setAtomValue = (atom, value, nextDependencies, keepPreviousDependencies) => {\n    const prevAtomState = getAtomState(atom);\n    const nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),\n      v: value\n    };\n    if (nextDependencies) {\n      updateDependencies(\n        atom,\n        nextAtomState,\n        nextDependencies,\n        keepPreviousDependencies\n      );\n    }\n    if (isEqualAtomValue(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    if (hasPromiseAtomValue(prevAtomState) && hasPromiseAtomValue(nextAtomState) && isEqualPromiseAtomValue(prevAtomState, nextAtomState)) {\n      if (prevAtomState.d === nextAtomState.d) {\n        return prevAtomState;\n      } else {\n        nextAtomState.v = prevAtomState.v;\n      }\n    }\n    setAtomState(atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomValueOrPromise = (atom, valueOrPromise, nextDependencies, abortPromise) => {\n    if (isPromiseLike(valueOrPromise)) {\n      let continuePromise;\n      const updatePromiseDependencies = () => {\n        const prevAtomState = getAtomState(atom);\n        if (!hasPromiseAtomValue(prevAtomState) || prevAtomState.v !== promise) {\n          return;\n        }\n        const nextAtomState = setAtomValue(\n          atom,\n          promise,\n          nextDependencies\n        );\n        if (mountedMap.has(atom) && prevAtomState.d !== nextAtomState.d) {\n          mountDependencies(atom, nextAtomState, prevAtomState.d);\n        }\n      };\n      const promise = new Promise((resolve, reject) => {\n        let settled = false;\n        valueOrPromise.then(\n          (v) => {\n            if (!settled) {\n              settled = true;\n              resolvePromise(promise, v);\n              resolve(v);\n              updatePromiseDependencies();\n            }\n          },\n          (e) => {\n            if (!settled) {\n              settled = true;\n              rejectPromise(promise, e);\n              reject(e);\n              updatePromiseDependencies();\n            }\n          }\n        );\n        continuePromise = (next) => {\n          if (!settled) {\n            settled = true;\n            next.then(\n              (v) => resolvePromise(promise, v),\n              (e) => rejectPromise(promise, e)\n            );\n            resolve(next);\n          }\n        };\n      });\n      promise.orig = valueOrPromise;\n      promise.status = \"pending\";\n      registerCancelPromise(promise, (next) => {\n        if (next) {\n          continuePromise(next);\n        }\n        abortPromise == null ? void 0 : abortPromise();\n      });\n      return setAtomValue(atom, promise, nextDependencies, true);\n    }\n    return setAtomValue(atom, valueOrPromise, nextDependencies);\n  };\n  const setAtomError = (atom, error, nextDependencies) => {\n    const prevAtomState = getAtomState(atom);\n    const nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),\n      e: error\n    };\n    if (nextDependencies) {\n      updateDependencies(atom, nextAtomState, nextDependencies);\n    }\n    if (isEqualAtomError(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    setAtomState(atom, nextAtomState);\n    return nextAtomState;\n  };\n  const readAtomState = (atom, force) => {\n    const atomState = getAtomState(atom);\n    if (!force && atomState) {\n      if (mountedMap.has(atom)) {\n        return atomState;\n      }\n      if (Array.from(atomState.d).every(([a, s]) => {\n        if (a === atom) {\n          return true;\n        }\n        const aState = readAtomState(a);\n        return aState === s || isEqualAtomValue(aState, s);\n      })) {\n        return atomState;\n      }\n    }\n    const nextDependencies = /* @__PURE__ */ new Map();\n    let isSync = true;\n    const getter = (a) => {\n      if (isSelfAtom(atom, a)) {\n        const aState2 = getAtomState(a);\n        if (aState2) {\n          nextDependencies.set(a, aState2);\n          return returnAtomValue(aState2);\n        }\n        if (hasInitialValue(a)) {\n          nextDependencies.set(a, void 0);\n          return a.init;\n        }\n        throw new Error(\"no atom init\");\n      }\n      const aState = readAtomState(a);\n      nextDependencies.set(a, aState);\n      return returnAtomValue(aState);\n    };\n    let controller;\n    let setSelf;\n    const options = {\n      get signal() {\n        if (!controller) {\n          controller = new AbortController();\n        }\n        return controller.signal;\n      },\n      get setSelf() {\n        if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !isActuallyWritableAtom(atom)) {\n          console.warn(\"setSelf function cannot be used with read-only atom\");\n        }\n        if (!setSelf && isActuallyWritableAtom(atom)) {\n          setSelf = (...args) => {\n            if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && isSync) {\n              console.warn(\"setSelf function cannot be called in sync\");\n            }\n            if (!isSync) {\n              return writeAtom(atom, ...args);\n            }\n          };\n        }\n        return setSelf;\n      }\n    };\n    try {\n      const valueOrPromise = atom.read(getter, options);\n      return setAtomValueOrPromise(\n        atom,\n        valueOrPromise,\n        nextDependencies,\n        () => controller == null ? void 0 : controller.abort()\n      );\n    } catch (error) {\n      return setAtomError(atom, error, nextDependencies);\n    } finally {\n      isSync = false;\n    }\n  };\n  const readAtom = (atom) => returnAtomValue(readAtomState(atom));\n  const addAtom = (atom) => {\n    let mounted = mountedMap.get(atom);\n    if (!mounted) {\n      mounted = mountAtom(atom);\n    }\n    return mounted;\n  };\n  const canUnmountAtom = (atom, mounted) => !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom));\n  const delAtom = (atom) => {\n    const mounted = mountedMap.get(atom);\n    if (mounted && canUnmountAtom(atom, mounted)) {\n      unmountAtom(atom);\n    }\n  };\n  const recomputeDependents = (atom) => {\n    const getDependents = (a) => {\n      var _a;\n      const dependents = new Set((_a = mountedMap.get(a)) == null ? void 0 : _a.t);\n      pendingMap.forEach((_, pendingAtom) => {\n        var _a2;\n        if ((_a2 = getAtomState(pendingAtom)) == null ? void 0 : _a2.d.has(a)) {\n          dependents.add(pendingAtom);\n        }\n      });\n      return dependents;\n    };\n    const topsortedAtoms = new Array();\n    const markedAtoms = /* @__PURE__ */ new Set();\n    const visit = (n) => {\n      if (markedAtoms.has(n)) {\n        return;\n      }\n      markedAtoms.add(n);\n      for (const m of getDependents(n)) {\n        if (n !== m) {\n          visit(m);\n        }\n      }\n      topsortedAtoms.push(n);\n    };\n    visit(atom);\n    const changedAtoms = /* @__PURE__ */ new Set([atom]);\n    for (let i = topsortedAtoms.length - 1; i >= 0; --i) {\n      const a = topsortedAtoms[i];\n      const prevAtomState = getAtomState(a);\n      if (!prevAtomState) {\n        continue;\n      }\n      let hasChangedDeps = false;\n      for (const dep of prevAtomState.d.keys()) {\n        if (dep !== a && changedAtoms.has(dep)) {\n          hasChangedDeps = true;\n          break;\n        }\n      }\n      if (hasChangedDeps) {\n        const nextAtomState = readAtomState(a, true);\n        if (!isEqualAtomValue(prevAtomState, nextAtomState)) {\n          changedAtoms.add(a);\n        }\n      }\n    }\n  };\n  const writeAtomState = (atom, ...args) => {\n    let isSync = true;\n    const getter = (a) => returnAtomValue(readAtomState(a));\n    const setter = (a, ...args2) => {\n      let r;\n      if (isSelfAtom(atom, a)) {\n        if (!hasInitialValue(a)) {\n          throw new Error(\"atom not writable\");\n        }\n        const prevAtomState = getAtomState(a);\n        const nextAtomState = setAtomValueOrPromise(a, args2[0]);\n        if (!isEqualAtomValue(prevAtomState, nextAtomState)) {\n          recomputeDependents(a);\n        }\n      } else {\n        r = writeAtomState(a, ...args2);\n      }\n      if (!isSync) {\n        const flushed = flushPending();\n        if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n          storeListenersRev2.forEach(\n            (l) => l({ type: \"async-write\", flushed })\n          );\n        }\n      }\n      return r;\n    };\n    const result = atom.write(getter, setter, ...args);\n    isSync = false;\n    return result;\n  };\n  const writeAtom = (atom, ...args) => {\n    const result = writeAtomState(atom, ...args);\n    const flushed = flushPending();\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      storeListenersRev2.forEach(\n        (l) => l({ type: \"write\", flushed })\n      );\n    }\n    return result;\n  };\n  const mountAtom = (atom, initialDependent, onMountQueue) => {\n    var _a;\n    const queue = onMountQueue || [];\n    (_a = getAtomState(atom)) == null ? void 0 : _a.d.forEach((_, a) => {\n      const aMounted = mountedMap.get(a);\n      if (aMounted) {\n        aMounted.t.add(atom);\n      } else {\n        if (a !== atom) {\n          mountAtom(a, atom, queue);\n        }\n      }\n    });\n    readAtomState(atom);\n    const mounted = {\n      t: new Set(initialDependent && [initialDependent]),\n      l: /* @__PURE__ */ new Set()\n    };\n    mountedMap.set(atom, mounted);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      mountedAtoms.add(atom);\n    }\n    if (isActuallyWritableAtom(atom) && atom.onMount) {\n      const { onMount } = atom;\n      queue.push(() => {\n        const onUnmount = onMount((...args) => writeAtom(atom, ...args));\n        if (onUnmount) {\n          mounted.u = onUnmount;\n        }\n      });\n    }\n    if (!onMountQueue) {\n      queue.forEach((f) => f());\n    }\n    return mounted;\n  };\n  const unmountAtom = (atom) => {\n    var _a;\n    const onUnmount = (_a = mountedMap.get(atom)) == null ? void 0 : _a.u;\n    if (onUnmount) {\n      onUnmount();\n    }\n    mountedMap.delete(atom);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      mountedAtoms.delete(atom);\n    }\n    const atomState = getAtomState(atom);\n    if (atomState) {\n      if (hasPromiseAtomValue(atomState)) {\n        cancelPromise(atomState.v);\n      }\n      atomState.d.forEach((_, a) => {\n        if (a !== atom) {\n          const mounted = mountedMap.get(a);\n          if (mounted) {\n            mounted.t.delete(atom);\n            if (canUnmountAtom(a, mounted)) {\n              unmountAtom(a);\n            }\n          }\n        }\n      });\n    } else if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      console.warn(\"[Bug] could not find atom state to unmount\", atom);\n    }\n  };\n  const mountDependencies = (atom, atomState, prevDependencies) => {\n    const depSet = new Set(atomState.d.keys());\n    const maybeUnmountAtomSet = /* @__PURE__ */ new Set();\n    prevDependencies == null ? void 0 : prevDependencies.forEach((_, a) => {\n      if (depSet.has(a)) {\n        depSet.delete(a);\n        return;\n      }\n      maybeUnmountAtomSet.add(a);\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.delete(atom);\n      }\n    });\n    depSet.forEach((a) => {\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.add(atom);\n      } else if (mountedMap.has(atom)) {\n        mountAtom(a, atom);\n      }\n    });\n    maybeUnmountAtomSet.forEach((a) => {\n      const mounted = mountedMap.get(a);\n      if (mounted && canUnmountAtom(a, mounted)) {\n        unmountAtom(a);\n      }\n    });\n  };\n  const flushPending = () => {\n    let flushed;\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      flushed = /* @__PURE__ */ new Set();\n    }\n    while (pendingMap.size) {\n      const pending = Array.from(pendingMap);\n      pendingMap.clear();\n      pending.forEach(([atom, prevAtomState]) => {\n        const atomState = getAtomState(atom);\n        if (atomState) {\n          const mounted = mountedMap.get(atom);\n          if (mounted && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n            mountDependencies(atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n          }\n          if (mounted && !// TODO This seems pretty hacky. Hope to fix it.\n          // Maybe we could `mountDependencies` in `setAtomState`?\n          (!hasPromiseAtomValue(prevAtomState) && (isEqualAtomValue(prevAtomState, atomState) || isEqualAtomError(prevAtomState, atomState)))) {\n            mounted.l.forEach((listener) => listener());\n            if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n              flushed.add(atom);\n            }\n          }\n        } else if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n          console.warn(\"[Bug] no atom state to flush\");\n        }\n      });\n    }\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      return flushed;\n    }\n  };\n  const subscribeAtom = (atom, listener) => {\n    const mounted = addAtom(atom);\n    const flushed = flushPending();\n    const listeners = mounted.l;\n    listeners.add(listener);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      storeListenersRev2.forEach(\n        (l) => l({ type: \"sub\", flushed })\n      );\n    }\n    return () => {\n      listeners.delete(listener);\n      delAtom(atom);\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n        storeListenersRev2.forEach((l) => l({ type: \"unsub\" }));\n      }\n    };\n  };\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    return {\n      get: readAtom,\n      set: writeAtom,\n      sub: subscribeAtom,\n      // store dev methods (these are tentative and subject to change without notice)\n      dev_subscribe_store: (l, rev) => {\n        if (rev !== 2) {\n          throw new Error(\"The current StoreListener revision is 2.\");\n        }\n        storeListenersRev2.add(l);\n        return () => {\n          storeListenersRev2.delete(l);\n        };\n      },\n      dev_get_mounted_atoms: () => mountedAtoms.values(),\n      dev_get_atom_state: (a) => atomStateMap.get(a),\n      dev_get_mounted: (a) => mountedMap.get(a),\n      dev_restore_atoms: (values) => {\n        for (const [atom, valueOrPromise] of values) {\n          if (hasInitialValue(atom)) {\n            setAtomValueOrPromise(atom, valueOrPromise);\n            recomputeDependents(atom);\n          }\n        }\n        const flushed = flushPending();\n        storeListenersRev2.forEach(\n          (l) => l({ type: \"restore\", flushed })\n        );\n      }\n    };\n  }\n  return {\n    get: readAtom,\n    set: writeAtom,\n    sub: subscribeAtom\n  };\n};\nlet defaultStore;\nif ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n  if (typeof globalThis.__NUMBER_OF_JOTAI_INSTANCES__ === \"number\") {\n    ++globalThis.__NUMBER_OF_JOTAI_INSTANCES__;\n  } else {\n    globalThis.__NUMBER_OF_JOTAI_INSTANCES__ = 1;\n  }\n}\nconst getDefaultStore = () => {\n  if (!defaultStore) {\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && globalThis.__NUMBER_OF_JOTAI_INSTANCES__ !== 1) {\n      console.warn(\n        \"Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044\"\n      );\n    }\n    defaultStore = createStore();\n  }\n  return defaultStore;\n};\n\nexport { atom, createStore, getDefaultStore };\n","'use client';\nimport ReactExports, { createContext, useContext, useRef, createElement, useReducer, useEffect, useDebugValue, useCallback } from 'react';\nimport { getDefaultStore, createStore } from 'jotai/vanilla';\n\nconst StoreContext = createContext(void 0);\nconst useStore = (options) => {\n  const store = useContext(StoreContext);\n  return (options == null ? void 0 : options.store) || store || getDefaultStore();\n};\nconst Provider = ({\n  children,\n  store\n}) => {\n  const storeRef = useRef();\n  if (!store && !storeRef.current) {\n    storeRef.current = createStore();\n  }\n  return createElement(\n    StoreContext.Provider,\n    {\n      value: store || storeRef.current\n    },\n    children\n  );\n};\n\nconst isPromiseLike = (x) => typeof (x == null ? void 0 : x.then) === \"function\";\nconst use = ReactExports.use || ((promise) => {\n  if (promise.status === \"pending\") {\n    throw promise;\n  } else if (promise.status === \"fulfilled\") {\n    return promise.value;\n  } else if (promise.status === \"rejected\") {\n    throw promise.reason;\n  } else {\n    promise.status = \"pending\";\n    promise.then(\n      (v) => {\n        promise.status = \"fulfilled\";\n        promise.value = v;\n      },\n      (e) => {\n        promise.status = \"rejected\";\n        promise.reason = e;\n      }\n    );\n    throw promise;\n  }\n});\nfunction useAtomValue(atom, options) {\n  const store = useStore(options);\n  const [[valueFromReducer, storeFromReducer, atomFromReducer], rerender] = useReducer(\n    (prev) => {\n      const nextValue = store.get(atom);\n      if (Object.is(prev[0], nextValue) && prev[1] === store && prev[2] === atom) {\n        return prev;\n      }\n      return [nextValue, store, atom];\n    },\n    void 0,\n    () => [store.get(atom), store, atom]\n  );\n  let value = valueFromReducer;\n  if (storeFromReducer !== store || atomFromReducer !== atom) {\n    rerender();\n    value = store.get(atom);\n  }\n  const delay = options == null ? void 0 : options.delay;\n  useEffect(() => {\n    const unsub = store.sub(atom, () => {\n      if (typeof delay === \"number\") {\n        setTimeout(rerender, delay);\n        return;\n      }\n      rerender();\n    });\n    rerender();\n    return unsub;\n  }, [store, atom, delay]);\n  useDebugValue(value);\n  return isPromiseLike(value) ? use(value) : value;\n}\n\nfunction useSetAtom(atom, options) {\n  const store = useStore(options);\n  const setAtom = useCallback(\n    (...args) => {\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !(\"write\" in atom)) {\n        throw new Error(\"not writable atom\");\n      }\n      return store.set(atom, ...args);\n    },\n    [store, atom]\n  );\n  return setAtom;\n}\n\nfunction useAtom(atom, options) {\n  return [\n    useAtomValue(atom, options),\n    // We do wrong type assertion here, which results in throwing an error.\n    useSetAtom(atom, options)\n  ];\n}\n\nexport { Provider, useAtom, useAtomValue, useSetAtom, useStore };\n"],"names":["keyCount","atom","read","write","key","config","toString","init","defaultRead","defaultWrite","get","this","set","arg","isSelfAtom","a","unstable_is","hasInitialValue","isActuallyWritableAtom","cancelPromiseMap","WeakMap","cancelPromise","promise","next","cancel","delete","resolvePromise","value","status","rejectPromise","e","reason","isEqualAtomValue","b","Object","is","v","isEqualAtomError","hasPromiseAtomValue","Promise","returnAtomValue","atomState","createStore","atomStateMap","mountedMap","pendingMap","Map","storeListenersRev2","mountedAtoms","Set","getAtomState","setAtomState","freeze","prevAtomState","has","resolve","reject","updateDependencies","nextAtomState","nextDependencies","keepPreviousDependencies","dependencies","d","changed","forEach","aState","console","warn","size","setAtomValue","orig","setAtomValueOrPromise","valueOrPromise","abortPromise","x","then","continuePromise","updatePromiseDependencies","mountDependencies","settled","catch","finally","registerCancelPromise","readAtomState","force","Array","from","every","s","isSync","getter","aState2","Error","controller","setSelf","options","signal","AbortController","args","writeAtom","abort","error","setAtomError","canUnmountAtom","mounted","l","t","recomputeDependents","topsortedAtoms","markedAtoms","visit","n","add","m","_a","dependents","_","pendingAtom","_a2","getDependents","push","changedAtoms","i","length","hasChangedDeps","dep","keys","writeAtomState","result","args2","r","flushed","flushPending","type","mountAtom","initialDependent","onMountQueue","queue","aMounted","onMount","onUnmount","u","f","unmountAtom","prevDependencies","depSet","maybeUnmountAtomSet","pending","clear","listener","sub","addAtom","listeners","delAtom","dev_subscribe_store","rev","dev_get_mounted_atoms","values","dev_get_atom_state","dev_get_mounted","dev_restore_atoms","defaultStore","globalThis","__NUMBER_OF_JOTAI_INSTANCES__","getDefaultStore","StoreContext","createContext","useStore","store","useContext","Provider","children","storeRef","useRef","current","createElement","use","useAtomValue","valueFromReducer","storeFromReducer","atomFromReducer","rerender","useReducer","prev","nextValue","delay","useEffect","unsub","setTimeout","useDebugValue","useSetAtom","useCallback","useAtom"],"sourceRoot":""}